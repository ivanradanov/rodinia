/*
 * Do most of a dot product computation using two input vectors, 
 * output an array that simply needs to be summed at the end.
 */
__global__ void computeDotProductHelper(
        int *__restrict__ result,
  const int *__restrict__ v1,
  const int *__restrict__ v2,
  const int vLength) 
{

  extern  __shared__ int cache[];

  int cacheIndex = threadIdx.x;
  int tid = threadIdx.x + blockIdx.x * blockDim.x;

  int temp = 0;

  while (tid < vLength) {
    temp += v1[tid] * v2[tid];
    tid += blockDim.x * gridDim.x;
  }

  cache[cacheIndex] = temp;
  __syncthreads();
  int i = blockDim.x/2;
  while(i != 0) {
    if (cacheIndex < i)
      cache[cacheIndex] += cache[cacheIndex + i];
    __syncthreads();
    i /= 2;
  }

  if (cacheIndex == 0)
    result[blockIdx.x] = cache[0];
}


/*
 * Count how many elements in a vector exceed some threshold, outputting an array that simply needs to be summed at the end to get the final result.
 */
__global__ void countAboveThresholdHelper(
  const float *__restrict__ array, 
  const float threshold,
  int *__restrict__ counter,
  const int arrayLength)
{
  extern __shared__ int binomial[];

  int cacheIndex=threadIdx.x;
  int tid = threadIdx.x + blockIdx.x * blockDim.x;

  int ptemp = 0;

  while (tid < arrayLength) {
    if (array[tid] > threshold) {
      ptemp++;
    }
    tid += blockDim.x * gridDim.x;
  }

  binomial[cacheIndex] = ptemp;
  __syncthreads();
  int i = blockDim.x/2;
  while(i != 0) {
    if (cacheIndex < i)
      binomial[cacheIndex] += binomial[cacheIndex + i];
    __syncthreads();
    i /= 2;
  }

  if (cacheIndex == 0)
    counter[blockIdx.x] = binomial[0];
}


/*
 * Compute connection scores for randomized signatures, normalized to a given UCmax.
 * random should be a pointer to a (device) array containing uniformly distributed random values between 0-1 (including 0, but not including 1; these can be generated by CURAND).
 * A value > 0.5 indicates the randomly-selected gene that should be up-regulated, otherwise the gene should be down-regulated.
 * The same random number is then also used to select the gene, by rescaling its absolute value after subtracting 0.5 into an array index (effectively).
 */
__global__ void computeRandomConnectionScores(
  const float *__restrict__ random,
  const int *__restrict__ reffile,
        float *__restrict__ output,
  const int M, const float UCmax, const int setSize,
  const int nRandomGenerations)
{
  float temp = 0.0;
  int idx = blockIdx.x * blockDim.x + threadIdx.x;
  if (idx < nRandomGenerations) {
    for(int col = idx; col < M; col += nRandomGenerations) {
      // For converting to in-range indices, it helps to have the random numbers from 0 (inclusive) to 1 (non-inclusive) - so just flip them
      float n = 1.0f - random[col];
      // We'll ultimately want to normalize our results by the setSize - do it now, when round-off errors will hopefully cost less
      float regulateFactor = 1.0f / setSize;
      // If our random number now is >= 0.5, we'll downregulate - and subtract 0.5 so that 0 <= random < 0.5
      if (n >= 0.5f) {
        regulateFactor = -regulateFactor;
        n -= 0.5f;
      }
      // Scale up random to become an integer index < arraySizeEnd
      int rangeInArray = __float2int_rd(n * U133AArrayLength * 2);
      // Add or subtract the randomly selected value from the array to the cumulative total
      temp += reffile[rangeInArray] * regulateFactor;
    }
    // Update the output, further normalizing by UCmax
    output[idx] = temp / UCmax;
  }
}

